-module(backend_trace).

-export([start_link/0, trace/0]).

-import(utilities, [initial_call/1]).

start_link() ->
	{ok, init_trace()}.

init_trace() ->
	initialize_state(),
	spawn_link(?MODULE, trace, []).

trace() ->
	erlang:trace(whereis(backend), true, [set_on_spawn, send, procs, 'receive']),
	trace_loop([]).

trace_loop(TracerPid) ->
	receive Trace ->
		%io:format("~w from ~w~n", [Trace, self()]),
		case Trace of
		%{trace, From, send, {doctor_login, Name}, To} ->
		%	spawn(fun() -> 
		%		gen_fsm:send_event(backend_users_fsm, {'Login', {doctor_login, Name}})
		%	end),
		%	trace_loop(TracerPid);

		{trace, Pid, register, Name} ->
			spawn(fun() -> 
				Object = ets:lookup(hashTable, {Pid, patient}),
				if
				(Object /= []) ->
					io:format("register ~n", []),
					erlang:element(2, lists:last(Object)) ! {'$gen_event', {'Register', Name}};
				true ->
					true
				end
			end),
			trace_loop(TracerPid);

		{trace, _, spawn, Pid, {patient, newPatient, [Name]}} ->
			spawn(fun() -> 
				io:format("spawn ~n", []),
				ets:insert(hashTable, {{Pid, patient}, erlang:element(2, backend_patient_fsm:start_link(Pid))})
			end),
			trace_loop([]);

		{trace_ts, Pid, exit, _, _} ->
			spawn(fun() ->
				lists:foreach(fun(FsmPid) ->
					gen_fsm:send_event(lists:last(FsmPid), stop)
				end, ets:match(hashTable, {{Pid, '_'}, '$1'})),
				ets:match_delete(hashTable, {{Pid, '_'}, '_'})
			end),
			trace_loop(TracerPid);

		_ ->
			trace_loop([])
		end
	end.

initialize_state() ->
	case ets:info(hashTable) of
	undefined ->
		ets:new(hashTable, [named_table, bag, public]);
	_ ->
		true
	end.

